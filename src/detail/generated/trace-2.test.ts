// Autogenerated Detail test, do not edit.

const originalEnvironment = process.env;
process.env.NODE_ENV = "production";
process.env.DATABASE_URL = "REDACTED";
process.env.COPYSCAPE_USERNAME = "UNKNOWN";
process.env.COPYSCAPE_KEY = "REDACTED";
process.env.JUNE_KEY = "REDACTED";
process.env.MG_API_KEY = "REDACTED";
process.env.BUGSNAG_KEY = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
process.env.NANGO = "REDACTED";
process.env.SCREENSHOT_ONE_ACCESS_KEY = "REDACTED";
process.env.SCREENSHOT_ONE_SECRET_KEY = "REDACTED";
process.env.__DETAIL_TEST_MODE = "true";

import { libraries, request, utils } from "@detail-dev/replay";
import crypto from "crypto";

jest.mock("crypto", () => {
  const mCrypto = {
    ...jest.requireActual("crypto"),
  };
  return mCrypto;
});
jest.mock("@prisma/client", () =>
  libraries.PrismaInterceptor.createMock(jest.requireActual("@prisma/client")),
);

describe("POST /api/users", () => {
  let response: request.Response;
  let httpInterceptor: libraries.HttpInterceptor;

  let cryptoInterceptor: libraries.CryptoInterceptor;

  let dateInterceptor: libraries.DateInterceptor;

  // Set up prisma fixtures.
  const prismaCallsExpected = [
    {
      library: "prisma",
      input: {
        model: "User",
        operation: "findUnique",
        queryOptions: {
          where: {
            email: "james2@detail.dev",
          },
          select: {
            id: true,
          },
        },
      },
      output: {
        id: 75,
      },
      id: "65b7eacb787a8ea3",
      timestamp: 1715988399664000,
      startup: false,
    },
    {
      library: "prisma",
      input: {
        model: "User",
        operation: "findUnique",
        queryOptions: {
          where: {
            username: "detailboi2",
          },
          select: {
            id: true,
          },
        },
      },
      output: {
        id: 75,
      },
      id: "e98f45e85ae50196",
      timestamp: 1715988399683000,
      startup: false,
    },
  ];
  let prismaInterceptor: libraries.PrismaInterceptor;

  const EXPECTED_BODY =
    '{"errors":{"email":["has already been taken"],"username":["has already been taken"]}}';
  const EXPECTED_RESPONSE_HEADER = {
    "x-powered-by": "Express",
    "content-type": "application/json; charset=utf-8",
  };

  afterEach(async () => {
    jest.clearAllMocks();
    process.env = originalEnvironment;

    // Emit test results.
    utils.serializeTestResults("generated/test_results/2.json", {
      traceId: "e6434caecea918f04c2400c94c61579d",
      testFile: __filename.split("/").pop() as string,
      request: { pathKey: "/users", route: "/api/users", method: "POST" },
      response: {
        expected: {
          status: 422,
          body: EXPECTED_BODY,
          header: EXPECTED_RESPONSE_HEADER,
        },
        observed: {
          status: response.status,
          body:
            response.headers && response.headers["content-length"] == 0
              ? undefined
              : response.text || JSON.stringify(response.body),
          header: libraries.canonicalizeResHeaders(response.header),
        },
      },
      expectedCalls: [...prismaCallsExpected],
      observedCalls: [
        ...httpInterceptor.getObservedCalls(),
        ...cryptoInterceptor.getObservedCalls(),
        ...dateInterceptor.getObservedCalls(),
        ...prismaInterceptor.getObservedCalls(),
      ],
    });
  });

  it("should run as expected with example data", async () => {
    // @ts-expect-error we manage http mocking globally, so that we can reuse a
    // global polly server. We pass in hooks to manage the global state here.
    httpInterceptor = new libraries.HttpInterceptor(global.__HTTP_CALL_HOOKS__);
    httpInterceptor.expectCalls([]);

    cryptoInterceptor = new libraries.CryptoInterceptor(crypto);
    cryptoInterceptor.expectCalls([]);

    dateInterceptor = new libraries.DateInterceptor();
    dateInterceptor.expectCalls([]);

    prismaInterceptor = new libraries.PrismaInterceptor();
    prismaInterceptor.expectCalls(prismaCallsExpected);

    // Import the app.
    const { app } = await import("../config");

    // Make the request.
    response = await request(app)
      .post("/api/users")
      .set("content-type", "application/json")
      .set("user-agent", "PostmanRuntime/7.38.0")
      .set("accept", "*/*")
      .set("postman-token", "42d60260-207d-4913-88da-682e70e1c3dd")
      .set("host", "localhost:3000")
      .set("accept-encoding", "gzip, deflate, br")
      .set("connection", "keep-alive")
      .set("x-detail-originator", "detail")
      .send({
        user: {
          username: "detailboi2",
          password: "password",
          email: "james2@detail.dev",
        },
      });
  });
});
